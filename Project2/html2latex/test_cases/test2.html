<h1>CS302 Lecture notes -- NP Completeness</h1>
<ul>
<li> James S. Plank
</li><li> December 1, 2009.
</li><li> Latest revision: Dec  2 01:05:24 EST 2015
</li></ul>

<p>This is not a complete treatment of NP-Completeness.  Like the Halting Problem
lecture notes, they introduce you to a concept that you will see later in 
your CS careers and will provide you with fodder for endless conversations
around the family dinner table.</p>
<p>As always, you can spend quite a bit of time reading Wikipedia on the 
subject.  Their page is
in This is not required reading, but (as of 2015) is a nice treatment of the topic.
</p>
<p>P, NP, NP-Complete and NP-Hard are sets of problems, defined as follows:
</p>
<ul>
<li> <strong>P</strong>: problems whose solution is polynomial time in the size of their inputs.
</li><li> <strong>NP</strong>: problems whose solutions can be verified in polynomial time.
(NP stands for <i>non-deterministic polynomial time</i>).
</li><li> <strong>NP-Complete</strong>: A collection of problems in NP whose solutions may or may not
polynomial time.  We don't know.  However, if we can prove that one of them may be solved
in polynomial time, then all of them can.
</li><li> <strong>NP-Hard</strong>: A collection of problems that are not in NP, whose solutions are at least as hard
as the NP-Complete problems.  
</li></ul>
<p>

In this lecture, we are going to see what it takes to prove that problems belong
to these sets.  
Suppose you have a problem to solve, and you want to know its complexity class.
This takes two steps:
</p><ol>
<li> <i>Prove that it is in NP</i>.  Typically the problem is couched as
a <small>yes</small> or <small>no</small> problem involving a data structure, such 
as ``does there exist a simple cycle through a
given directed graph that visits all the nodes?''  
To prove it is in NP, you need to show that 
a <small>yes</small> solution can be checked in polynomial time.  
In the above example, you can check to see if a given path through the graph
is indeed a simple cycle in linear time.  Therefore, the problem is in 
<small>NP</small>.  You don't have to prove anything about the <small>no</small> solutions,
and you don't have to prove anything about how you'd calculate a solution.
<p>
</p></li><li> <i>Transform a known NP-Complete problem to this one in polynomial time</i>.  
Suppose the problem in question is <strong>Q</strong>,
and that <strong>L</strong> is a well-known NP-Complete problem like 
the <i>3-satisfiability</i> problem.  You need to show that if you have
any instance of problem <strong>L</strong>, you can transform it into an instance
of problem <strong>Q</strong> in polynomial time.  Thus, if you could solve problem
<strong>Q</strong> in polynomial time, you could solve problem <strong>L</strong> in polynomial
time.
</li></ol>

<p>If  you can do both of these things, then you have proved that a problem is
NP-Complete.  If you can prove that either of these things cannot be done, then you
have proved that a problem is not NP-Complete.  Sometimes you can't do come up
with good proofs, and you just don't know.  
</p>
<p>
The complexity classes P and NP-Hard may be put in terms of the above:
</p>
<ul>
<li> <b>P</b>: If we can prove that the solution to a problem may be calculated
in polynomial time, then the problem is in P.  All of the algorithms that we
have studied in this class, with the exception of enumeration, are in <strong>P</strong>.
<p>
</p></li><li> <strong>NP-Hard</strong>: These are problems that are not in NP; however, we can 
perform the transformation in step 2 of a known NP-Complete problem to these
problems.  Thus, they are <i>at least as hard</i> as the NP-Complete problems.
</li></ul>

